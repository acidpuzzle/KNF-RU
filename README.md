Kernel source file style guide (KNF)
====================================

Этот файл определяет предпочтительный стиль исходных файлов ядра в дереве
исходных текстов OpenBSD. Он также является руководством по предпочтительному
стилю кода пользовательского пространства. Этим рекомендациям следует следовать
для всего нового кода. В общем случае, код можно считать "новым", если он
составляет около 50% или более от общего объема файла(ов). Этого достаточно,
чтобы отказаться от прецедентов в существующем коде и использовать текущее
руководство по стилю.

```
/*
 * Style guide for the OpenBSD KNF (Kernel Normal Form).
 */
```
```
/*
 * ОЧЕНЬ важные однострочные комментарии выглядят следующим образом.
 */
```
```
/* Большинство однострочных комментариев выглядят так. */
```
```
/*
 * Многострочные комментарии выглядят следующим образом.  Сделайте их настоящими предложениями.
 * Заполните их так, чтобы они выглядели как настоящие параграфы.
 */
```

На первом месте стоят включаемые файлы ядра (т.е. __<sys/*.h>__); обычно
требуется
__<sys/types.h>__ ИЛИ __<sys/param.h>__, но не оба! __<sys/types.h>__ включает
__<sys/cdefs.h>__, и от него можно зависеть.

```
#include <sys/types.h>   /* Не локальное включение, угловые скобки. */
```

Если это сетевая программа, поместите сетевые включаемые файлы рядом.

```
#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <netinet/in.h>
```

Затем идет пустая строка, за которой следуют файлы */usr/include*.
Файлы */usr/include*, по большей части, должны быть отсортированы.

Глобальные имена путей определяются в файле */usr/include/paths.h*. Локальные
для программы имена путей находятся в файле *pathnames.h* в локальном каталоге.

```
#include <paths.h>
```

Затем идет пустая строка и включаемые пользователем файлы.

```
#include "pathnames.h"   /* Локальные включения заключаются в двойные кавычки. */
```

Все нестатические функции где-то прототипируются.

Прототипы функций для частных функций (т.е. функций, не используемых в других
местах) размещаются в верхней части первого исходного модуля. В ядре частные
функции не требуют прототипа, если они определены до их использования. В
пространстве пользователя функции, локальные для одного исходного модуля,
должны быть объявлены как "статические". В ядре этого делать не следует, так
как это делает невозможным использование отладчика ядра.

Функции, используемые из других файлов, прототипируются в соответствующем
включаемом файле.

Функции, которые используются локально более чем в одном модуле, выносятся в
отдельный заголовочный файл, например, *extern.h*.

Прототипы не должны иметь имен переменных, связанных с типами; т.е,

```
void function(int);
```

НЕТ:

```
void function(int a);
```

Прототипы могут иметь дополнительный пробел после табуляции для того, чтобы
имена функций были выстроены в ряд:

```
static char    *function(int, const char *);
static void     usage(void);
```

Между именем функции и списком аргументов не должно быть пробела.

Используйте *\__dead* из **<sys/cdefs.h>** для функций, которые не возвращают, т.е,

```
__dead void    abort(void);
```

В заголовочных файлах прототипы функций следует помещать в пары
соответствия *\__BEGIN_DECLS* / *\__END_DECLS*. Это делает заголовочный файл
пригодным для использования из языка Си++.

Макросы выделяются заглавными буквами и заключаются в круглые скобки, при этом
следует избегать побочных эффектов. Если макрос представляет собой встроенное
расширение функции, то функция определяется в нижнем регистре, а макрос имеет
то же имя в верхнем регистре. Если макрос занимает более одной строки,
используйте скобки. Обратные косые черты следует выравнивать вправо, так как
полученное определение легче читается. Если макрос содержит составной оператор,
заключите его в цикл "do", чтобы его можно было безопасно использовать в
операторах "if". Любая точка с запятой, завершающая оператор, должна быть
предоставлена вызовом макроса, а не самим макросом, чтобы облегчить разбор для
красивых принтеров и редакторов.

```
#define   MACRO(x, y) do {                        \
     variable = (x) + (y);                        \
     (y) += 2;                                    \
} while (0)
```

Если в макросе с аргументами объявляются локальные переменные, то эти переменные
должны иметь идентификаторы, начинающиеся с двух знаков подчеркивания. Это
требуется для макросов, реализующих интерфейсы C и POSIX, и рекомендуется для
всех макросов для согласованности.

Значения перечислений приводятся в верхнем регистре.

```
enum enumtype { ONE, TWO } et;
```

При определении беззнаковых целых чисел следует использовать "unsigned int", а
не просто "unsigned"; последнее в прошлом вызывало путаницу.

При объявлении переменных в структурах следует объявлять их в порядке
использования, затем по размеру (от наибольшего к наименьшему), затем в
алфавитном порядке. Первая категория обычно не применяется, но бывают и
исключения. Каждому из них отводится отдельная строка. Поставьте табуляцию
после первого слова, т.е. используйте 'int^Ix;' и 'struct^Ifoo \*x;'.

Основные структуры должны быть объявлены в верхней части файла, в котором они
используются, или в отдельных заголовочных файлах, если они используются в
нескольких исходных файлах. Использование структур должно осуществляться
отдельными объявлениями и должно быть "extern", если они объявлены в
заголовочном файле.

```
struct foo {
     struct    foo *next;          /* List of active foo */
     struct    mumble amumble;     /* Comment for mumble */
     int       bar;
};
struct foo *foohead;               /* Head of global foo list */
```

По возможности используйте макросы [queue(3)](https://man.openbsd.org/queue.3), 
а не составляйте собственные списки. Таким образом, предыдущий пример 
лучше было бы написать так:

```
#include <sys/queue.h>
struct    foo {
     LIST_ENTRY(foo)     link;                /* Queue macro glue for foo lists */
     struct              mumble amumble;      /* Comment for mumble */
     int                 bar;
};
LIST_HEAD(, foo) foohead;                     /* Head of global foo list */
```

Избегайте использования типизаций для типов структур. Это делает невозможным
непрозрачное использование указателей на такую структуру, что возможно и
выгодно при использовании обычного тега struct. Если по правилам необходимо
использовать typedef, то его имя должно соответствовать тегу struct.
Избегайте типизаций, заканчивающихся на "\_t", за исключением случаев,
оговоренных в стандарте C или POSIX.

```
/*
 * Все основные подпрограммы должны иметь комментарий, кратко описывающий их
 * работу.  Комментарий перед "главной" процедурой должен описывать, что делает
 * программа.
 */
int
main(int argc, char *argv[])
{
     int aflag, bflag, ch, num;
     const char *errstr;
```
